diff -up linux-headers-4.9.13/drivers/mmc/core/mmc.c.orig linux-headers-4.9.13/drivers/mmc/core/mmc.c
--- linux-headers-4.9.13/drivers/mmc/core/mmc.c.orig	2017-02-26 11:11:18.000000000 +0100
+++ linux-headers-4.9.13/drivers/mmc/core/mmc.c	2017-04-09 08:36:40.000000000 +0200
@@ -1004,18 +1004,25 @@ static int mmc_select_bus_width(struct m
 }
 
 /* Caller must hold re-tuning */
-static int mmc_switch_status(struct mmc_card *card)
+static int __mmc_switch_status(struct mmc_card *card, bool crc_err_fatal)
 {
 	u32 status;
 	int err;
 
 	err = mmc_send_status(card, &status);
+	if (!crc_err_fatal && err == -EILSEQ)
+		return 0;
 	if (err)
 		return err;
 
 	return mmc_switch_status_error(card->host, status);
 }
 
+static int mmc_switch_status(struct mmc_card *card)
+{
+	return __mmc_switch_status(card, true);
+}
+
 /*
  * Switch to the high-speed mode
  */
@@ -1241,7 +1248,12 @@ int mmc_hs400_to_hs200(struct mmc_card *
 
 	mmc_set_timing(host, MMC_TIMING_MMC_HS200);
 
-	err = mmc_switch_status(card);
+	/*
+	 * For HS200, CRC errors are not a reliable way to know the switch
+	 * failed. If there really is a problem, we would expect tuning will
+	 * fail and the result ends up the same.
+	 */
+	err = __mmc_switch_status(card, false);
 	if (err)
 		goto out_err;
 
@@ -1397,7 +1409,12 @@ static int mmc_select_hs200(struct mmc_c
 		old_timing = host->ios.timing;
 		mmc_set_timing(host, MMC_TIMING_MMC_HS200);
 
-		err = mmc_switch_status(card);
+		/*
+		 * For HS200, CRC errors are not a reliable way to know the
+		 * switch failed. If there really is a problem, we would expect
+		 * tuning will fail and the result ends up the same.
+		 */
+		err = __mmc_switch_status(card, false);
 		/*
 		 * mmc_select_timing() assumes timing has not changed if
 		 * it is a switch error.
